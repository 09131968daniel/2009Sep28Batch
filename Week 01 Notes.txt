Naming conventions in Java

    Packages:
        reverse of an address
        lowercase
    Class
        noun
        TitleCase
    method
        verb
        camelCase
    field  
        noun
        camelCase
    interface
        adjective
        TitleCase
    final field / constant
        noun
        UPPER_CASE


How does Java achieve Encapsulation?

    With Access Modifires

    Access Modifires:
        Public:     Anywhere
        Protected:  within the same package and subclasses
        Default:    within the same package
        Private:    Within the same class
    Non-access Modifires:
        transient
        syncronized
        static
        final       //the field cannot be reassigned
                    //the method cannot be overriden
                    //the class cannot be extended
        abstract
        virtual
        naitive
        etc.

Packages and Imports

    Packages are how we can organize our classes
    Imports arem how we can bring classes in other packages into our class

    com.example.oop.accesscheck.FirstHubCap is the FULLY QUALIFIED NAME of FirstHubCap

    * birngs in all classes within the package, but not sub packages
    

Abstraction

    Interfaces:
        impliments instead of extends
            Interfaces can extends other Interfaces

        Public and abstract are implicit for methods inside of an interface
        public abstract void read(); = void read();

        Public, static, and final are implicit for fields inside of an interface

        public static final int something; = int something;

Control flow

    If statements
        if(boolean test){
            executed code if true
        }else executed code if false
    Switch statements
        switch(thing):{
            case "something":
                executed code if thing = "something"
                break;
            case "else"
                executed code if thing = "else"
                break;
            default:
                executed thing if thing != case "something", "else"
        }
    For loop
        int j = 0;
        for(int i=0;, i<10; i++){
            if(i==4){
                continue;
            }
            j++;
        }

    While loop
        while (condition) 
            executed code //executed if condition == true
    
    Do While loop 
        do{
            executed code //gets executed at least once
        }while(condition) // heads back to begining of Do block if condition true

Operators

    unary
        ++  addative incrimentor
        --  subtractive incrimentor

        ++X Pre incrimentor
        X++ post incrimentor

        !   not Operator
        ~   bitwise not

    binary
        +   addition
        -   subtraction
        *   multiplication
        /   divison
        %   modulus
        &&  AND
        ||  OR      (short circuting Operators)
        &   bitwise AND
        |   bitwise OR
        ^   exclusive Or
    
        =   assignment Operator
        ==  comparison Operator
        !=  not equal to Operator
        >   greater than
        <   less than
        >=  greater than or equal to
        <=  less than or equal to
        +=  addition assignment
        -=  subtraction assignment
        *=  multiplication assignment
        /=  division assignment
        %=  modulus assignment
    
    ternary
        condition ? ifTrue : ifFalse;


Scopes

    static(class)
    instance(object)
    method
    block ({block})
        

//==============================================================================================================================================================================================================//
                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||
//==============================================================================================================================================================================================================//

Strings

    String is a Final Class
    Strings are immutable
    Strings are stored in the String Pool
    String Pool
        Stored inside the Heap
        Strings are stored as a Final char[]
    Methods
        .equals(String string) //compares two strings
        .substring(int i)       //returns a substring between the given indexes. begining(inclusive) ending(exclusive)
        .length()
        .toUpperCase()
        .toLowerCase()
        .charAt(int i)          //returns char @ i
        .indexOf(char 'x')      //returns index of x in String

    what if Strings were mutable?
        String Builder  faster & thread unsafe
        String Buffer   slower & thread safe
            .append(String "xy")    //appends "xy" to the end of the string

Wrapper Classes 

    Wrapper classes are the object representation of primative data types

        int     ->  Intager
        char    ->  Character
        long    ->  Long
        short   ->  Short
        double  ->  Double
        boolean ->  boolean
        byte    ->  byte

        Integer i = new Integer(5)
        integer i2 = 5;             //autoboxing
        int i3 = i;                 //un-boxing

Generics

    Introduced in Java 5
    public class GenericsExample<T>
        private T hiddenValue
        public void setHiddenValue(T i){
            this.hiddenValue = i;
        }
        public T getHiddenValue(){
            return hiddenValue;
        }


Arrays
    
    An array is a collection of values of a certain data type.
    Ways to instantiate arrays
        int[] arr = new int[5];
        [] int arr2 = new int[5];
        int[] arr = {3,4,5,7,2,3}
        int... arr = {3,8,5,7,6,2}
    Ways to set value of item at index x
    arr[x]=5;               //the index of x contains int = 5

    for each loop control

    for(int a: arr){
        System.out.println(a);
    }

    Arrays is a Static Utilities class
        .toString(arr)
        .sort(arr)

Collections Framework
                                                                Comparable (I)   (Natural Sorting Order)
                                                                Comparator (I)   (Unnatural Sorting Order)
                    Iterable (Interface)                        Collections (C)  (Static Utility class)
                                ^                             
                                |
                                |
                    Collection (Interface)  
                    /                 |                  \
                List (I)            Set(I)               Queue(I)                       Map(I)
                ^                       ^                   ^                              ^
                |                       |                   |                              |
                |                       |                   |                              |
                ArrayList(C)        HashSet (C)         PriorityQueue(C)                HashMap (C)
                LinkedList(C)       TreeSet (C)         Deque(I)                        TreeMap (C)
                Stack(C)(LILO)

                List Keeps Order    Set doesn't         FIFO                            
                                    allow Duplicates