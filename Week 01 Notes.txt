Naming conventions in Java

    Packages:
        reverse of an address
        lowercase
    Class
        noun
        TitleCase
    method
        verb
        camelCase
    field  
        noun
        camelCase
    interface
        adjective
        TitleCase
    final field / constant
        noun
        UPPER_CASE


How does Java achieve Encapsulation?

    With Access Modifires

    Access Modifires:
        Public:     Anywhere
        Protected:  within the same package and subclasses
        Default:    within the same package
        Private:    Within the same class
    Non-access Modifires:
        transient
        syncronized
        static
        final       //the field cannot be reassigned
                    //the method cannot be overriden
                    //the class cannot be extended
        abstract
        virtual
        naitive
        etc.

Packages and Imports

    Packages are how we can organize our classes
    Imports arem how we can bring classes in other packages into our class

    com.example.oop.accesscheck.FirstHubCap is the FULLY QUALIFIED NAME of FirstHubCap

    * birngs in all classes within the package, but not sub packages
    

Abstraction

    Interfaces:
        impliments instead of extends
            Interfaces can extends other Interfaces

        Public and abstract are implicit for methods inside of an interface
        public abstract void read(); = void read();

        Public, static, and final are implicit for fields inside of an interface

        public static final int something; = int something;

Control flow

    If statements
        if(boolean test){
            executed code if true
        }else executed code if false
    Switch statements
        switch(thing):{
            case "something":
                executed code if thing = "something"
                break;
            case "else"
                executed code if thing = "else"
                break;
            default:
                executed thing if thing != case "something", "else"
        }
    For loop
        int j = 0;
        for(int i=0;, i<10; i++){
            if(i==4){
                continue;
            }
            j++;
        }

    While loop
        while (condition) 
            executed code //executed if condition == true
    
    Do While loop 
        do{
            executed code //gets executed at least once
        }while(condition) // heads back to begining of Do block if condition true

Operators

    unary
        ++  addative incrimentor
        --  subtractive incrimentor

        ++X Pre incrimentor
        X++ post incrimentor

        !   not Operator
        ~   bitwise not

    binary
        +   addition
        -   subtraction
        *   multiplication
        /   divison
        %   modulus
        &&  AND
        ||  OR      (short circuting Operators)
        &   bitwise AND
        |   bitwise OR
        ^   exclusive Or
    
        =   assignment Operator
        ==  comparison Operator
        !=  not equal to Operator
        >   greater than
        <   less than
        >=  greater than or equal to
        <=  less than or equal to
        +=  addition assignment
        -=  subtraction assignment
        *=  multiplication assignment
        /=  division assignment
        %=  modulus assignment
    
    ternary
        condition ? ifTrue : ifFalse;


Scopes

    static(class)
    instance(object)
    method
    block ({block})
        

//==============================================================================================================================================================================================================//
                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||
//==============================================================================================================================================================================================================//

Strings

    String is a Final Class
    Strings are immutable
    Strings are stored in the String Pool
    String Pool
        Stored inside the Heap
        Strings are stored as a Final char[]
    Methods
        .equals(String string) //compares two strings
        .substring(int i)       //returns a substring between the given indexes. begining(inclusive) ending(exclusive)
        .length()
        .toUpperCase()
        .toLowerCase()
        .charAt(int i)          //returns char @ i
        .indexOf(char 'x')      //returns index of x in String

    what if Strings were mutable?
        String Builder  faster & thread unsafe
        String Buffer   slower & thread safe
            .append(String "xy")    //appends "xy" to the end of the string

Wrapper Classes 

    Wrapper classes are the object representation of primative data types

        int     ->  Intager
        char    ->  Character
        long    ->  Long
        short   ->  Short
        double  ->  Double
        boolean ->  boolean
        byte    ->  byte

        Integer i = new Integer(5)
        integer i2 = 5;             //autoboxing
        int i3 = i;                 //un-boxing

Generics

    Introduced in Java 5
    public class GenericsExample<T>
        private T hiddenValue
        public void setHiddenValue(T i){
            this.hiddenValue = i;
        }
        public T getHiddenValue(){
            return hiddenValue;
        }


Arrays
    
    An array is a collection of values of a certain data type.
    Ways to instantiate arrays
        int[] arr = new int[5];
        [] int arr2 = new int[5];
        int[] arr = {3,4,5,7,2,3}
        int... arr = {3,8,5,7,6,2}
    Ways to set value of item at index x
    arr[x]=5;               //the index of x contains int = 5

    for each loop control

    for(int a: arr){
        System.out.println(a);
    }

    Arrays is a Static Utilities class
        .toString(arr)
        .sort(arr)

Collections Framework
                                                                Comparable (I)   (Natural Sorting Order)
                                                                Comparator (I)   (Unnatural Sorting Order)
                    Iterable (Interface)                        Collections (C)  (Static Utility class)
                                ^                             
                                |
                                |
                    Collection (Interface)  
                    /                 |                  \
                List (I)            Set(I)               Queue(I)                       Map(I)
                ^                       ^                   ^                              ^
                |                       |                   |                              |
                |                       |                   |                              |
                ArrayList(C)        HashSet (C)         PriorityQueue(C)                HashMap (C) // Use for question 6
                LinkedList(C)       TreeSet (C)         Deque(I)                        TreeMap (C)
                Stack(C)(LILO)

                List Keeps Order    Set doesn't         FIFO                            
                                    allow Duplicates
                                    Not Ordered
    import java.utils.*


    public class CollectionsExample{
        public static void main (String[] args){
            /*ArrayList 
            *   Expands the underlying array by 50%, not syncronized (THREAD UNSAFE)
            *
            *Vector
            *   impliments list, expands underlying array by 50%, syncronized (THREAD SAFE)
            */
            List<Integer> ints = new ArrayList();
            ints.add(4);
            ints.add(6);
            ints.add(7);
            System.out.println(ints);
            System.out.println(ints.get(i));
            System.out.println(ints.size());
            
            /*LinkedList
            *   Doubly linked list. it has references to the next and the previous node. 
            *   The underlying data structure does not house a conventional array, it will 
            *   add nodes to the list and references it to the previous and next nodesl It impliments 
            *   the Deque interface so retriving from the first and last positions will be O(1); 
            *   however, retrieving from the middle of the list will be the same as a normal array.
            */
            List<String> strings = new LinkedList<>();
            strings.add("added");
            strings.add(0, "adfjkhf");
            System.out.println(strings);
            System.out.println(strings.get(0));
            strings.clear();
            System.out.println(strings)

            //Sets
            

            //HashSet
            // Uses a underlying HashTable to organize and store values
            Set<Integer> intset = new HashSet();
            
            intset.add(8);
            intset.add(3838);
            intset.add(65);
            System.out.println(intset);
            intset.addAll(ints);
            boolean b = intset.add(4);      //returns bool whether or not the value was added to the Set
            System.out.println(inset);
            System.out.println(b);

            //TreeSet
            // uses a red black tree algorithm for sorting values

            Set<String> sortedStrings = new TreeSet<>();
            sortedStrings.add("Go time");
            sortedStrings.add("a bird in the sky");
            sortedStrings.add("Zoo goers");
            System.out.println(sortedStrings); // Capital Letters come first. Sorted by ASCII Code

            //Queue

            //PriorityQueue
            //      keeps everything organized by priority. Queue customarily keeps values in order as they are put in. 
            //      This will keep them in order by priority. the first one out will be the one with the highest priority.
            PriorityQueue<String> pq = new PriorityQueue();
            pq.add("hey look mah");
            pq.add("no hands!");
            System.out.println(pq.remove());
            System.out.println(pq.remove());
            System.out.println(pq.remove());    //Throws Out of bounds exeption
            ints.get(100);                      //Throws out of bounds exeption

            //Deque
            //  Double ended Queue, can retrieve from either end.

            //Map

            //HashMap  
            //      HashMap is like Hash Table, but is not syncronized and is faster
            Map<String, String> hashedStrings = new HashMap();
            hashedStrings.put("Key", "Value");
            hashedStrings.put("Another Key", "Another Value");
            System.out.println(hashedStrings);

            //TreeMap
            //      Like TreeSet, is going to organize the elements according to thier natural sorting order
            Map<String, String> dic = new TreeMap();
            dic.put("aardvark","a difficult to spell animal");
            dic.put("hammer","a thing to hit things with");
            dic.put("car", "a thing to go places");
            System.out.println(dic);
            System.out.println(dic.keySet());
            System.out.println(dic.values());
            System.out.println(dic.values().getClass());
            }


    }