Naming conventions in Java

    Packages:
        reverse of an address
        lowercase
    Class
        noun
        TitleCase
    method
        verb
        camelCase
    field  
        noun
        camelCase
    interface
        adjective
        TitleCase
    final field / constant
        noun
        UPPER_CASE


How does Java achieve Encapsulation?

    With Access Modifires

    Access Modifires:
        Public:     Anywhere
        Protected:  within the same package and subclasses
        Default:    within the same package
        Private:    Within the same class
    Non-access Modifires:
        transient      // marks a member field to not be serialized when it is persisted to a stream of bytes
        syncronized     // syncronized between all threads. slow.
        static      // can be accessed without instantiation
        final       //the field cannot be reassigned
                    //the method cannot be overriden
                    //the class cannot be extended
        abstract    //cannot be instantiated does not have to have implementation inside of an interface
        virtual     
        naitive     //breaks platform independence
        etc.

Packages and Imports

    Packages are how we can organize our classes
    Imports arem how we can bring classes in other packages into our class

    com.example.oop.accesscheck.FirstHubCap is the FULLY QUALIFIED NAME of FirstHubCap

    * brings in all classes within the package, but not sub packages
    

Abstraction

    Interfaces:
        impliments instead of extends
            Interfaces can extends other Interfaces

        Public and abstract are implicit for methods inside of an interface
        public abstract void read(); = void read();

        Public, static, and final are implicit for fields inside of an interface

        public static final int something; = int something;

Control flow

    If statements
        if(boolean test){
            executed code if true
        }else executed code if false
    Switch statements
        switch(thing):{
            case "something":
                executed code if thing = "something"
                break;
            case "else"
                executed code if thing = "else"
                break;
            default:
                executed thing if thing != case "something", "else"
        }
    For loop
        int j = 0;
        for(int i=0;, i<10; i++){
            if(i==4){
                continue;
            }
            j++;
        }

    While loop
        while (condition) 
            executed code //executed if condition == true
    
    Do While loop 
        do{
            executed code //gets executed at least once
        }while(condition) // heads back to begining of Do block if condition true

Operators

    unary
        ++  addative incrimentor
        --  subtractive incrimentor

        ++X Pre incrimentor
        X++ post incrimentor

        !   not Operator
        ~   bitwise not

    binary
        +   addition
        -   subtraction
        *   multiplication
        /   divison
        %   modulus
        &&  AND
        ||  OR      (short circuting Operators)
        &   bitwise AND
        |   bitwise OR
        ^   exclusive Or
    
        =   assignment Operator
        ==  comparison Operator
        !=  not equal to Operator
        >   greater than
        <   less than
        >=  greater than or equal to
        <=  less than or equal to
        +=  addition assignment
        -=  subtraction assignment
        *=  multiplication assignment
        /=  division assignment
        %=  modulus assignment
    
    ternary
        condition ? ifTrue : ifFalse;


Scopes

    static(class)
    instance(object)
    method
    block ({block})
        

//==============================================================================================================================================================================================================//
                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||                    |||  Intermediate Java  |||
//==============================================================================================================================================================================================================//

Strings

    String is a Final Class
    Strings are immutable
    Strings are stored in the String Pool
    String Pool
        Stored inside the Heap
        Strings are stored as a Final char[]
    Methods
        .equals(String string) //compares two strings
        .substring(int i)       //returns a substring between the given indexes. begining(inclusive) ending(exclusive)
        .length()
        .toUpperCase()
        .toLowerCase()
        .charAt(int i)          //returns char @ i
        .indexOf(char 'x')      //returns index of x in String

    what if Strings were mutable?
        String Builder  faster & thread unsafe
        String Buffer   slower & thread safe
            .append(String "xy")    //appends "xy" to the end of the string

Wrapper Classes 

    Wrapper classes are the object representation of primative data types

        int     ->  Intager
        char    ->  Character
        long    ->  Long
        short   ->  Short
        double  ->  Double
        boolean ->  boolean
        byte    ->  byte

        Integer i = new Integer(5)
        integer i2 = 5;             //autoboxing
        int i3 = i;                 //un-boxing

Generics

    Introduced in Java 5
    public class GenericsExample<T>
        private T hiddenValue
        public void setHiddenValue(T i){
            this.hiddenValue = i;
        }
        public T getHiddenValue(){
            return hiddenValue;
        }


Arrays
    
    An array is a collection of values of a certain data type.
    Ways to instantiate arrays
        int[] arr = new int[5];
        [] int arr2 = new int[5];
        int[] arr = {3,4,5,7,2,3}
        int... arr = {3,8,5,7,6,2}
    Ways to set value of item at index x
    arr[x]=5;               //the index of x contains int = 5

    for each loop control

    for(int a: arr){
        System.out.println(a);
    }

    Arrays is a Static Utilities class
        .toString(arr)
        .sort(arr)

Collections Framework
                                                                Comparable (I)   (Natural Sorting Order)
                                                                Comparator (I)   (Unnatural Sorting Order)
                    Iterable (Interface)                        Collections (C)  (Static Utility class)
                                ^                             
                                |
                                |
                    Collection (Interface)  
                    /                 |                  \
                List (I)            Set(I)               Queue(I)                       Map(I)
                ^                       ^                   ^                              ^
                |                       |                   |                              |
                |                       |                   |                              |
                ArrayList(C)        HashSet (C)         PriorityQueue(C)                HashMap (C) // Use for question 6
                LinkedList(C)       TreeSet (C)         Deque(I)                        TreeMap (C)
                Stack(C)(LILO)

                List Keeps Order    Set doesn't         FIFO                            
                                    allow Duplicates
                                    Not Ordered
    import java.utils.*


    public class CollectionsExample{
        public static void main (String[] args){
            /*ArrayList 
            *   Expands the underlying array by 50%, not syncronized (THREAD UNSAFE)
            *
            *Vector
            *   impliments list, expands underlying array by 50%, syncronized (THREAD SAFE)
            */
            List<Integer> ints = new ArrayList();
            ints.add(4);
            ints.add(6);
            ints.add(7);
            System.out.println(ints);
            System.out.println(ints.get(i));
            System.out.println(ints.size());
            
            /*LinkedList
            *   Doubly linked list. it has references to the next and the previous node. 
            *   The underlying data structure does not house a conventional array, it will 
            *   add nodes to the list and references it to the previous and next nodesl It impliments 
            *   the Deque interface so retriving from the first and last positions will be O(1); 
            *   however, retrieving from the middle of the list will be the same as a normal array.
            */
            List<String> strings = new LinkedList<>();
            strings.add("added");
            strings.add(0, "adfjkhf");
            System.out.println(strings);
            System.out.println(strings.get(0));
            strings.clear();
            System.out.println(strings)

            //Sets
            

            //HashSet
            // Uses a underlying HashTable to organize and store values
            Set<Integer> intset = new HashSet();
            
            intset.add(8);
            intset.add(3838);
            intset.add(65);
            System.out.println(intset);
            intset.addAll(ints);
            boolean b = intset.add(4);      //returns bool whether or not the value was added to the Set
            System.out.println(inset);
            System.out.println(b);

            //TreeSet
            // uses a red black tree algorithm for sorting values

            Set<String> sortedStrings = new TreeSet<>();
            sortedStrings.add("Go time");
            sortedStrings.add("a bird in the sky");
            sortedStrings.add("Zoo goers");
            System.out.println(sortedStrings); // Capital Letters come first. Sorted by ASCII Code

            //Queue
            // FIFO

            //PriorityQueue
            //      keeps everything organized by priority. Queue customarily keeps values in order as they are put in. 
            //      This will keep them in order by priority. the first one out will be the one with the highest priority.
            PriorityQueue<String> pq = new PriorityQueue();
            pq.add("hey look mah");
            pq.add("no hands!");
            System.out.println(pq.remove());
            System.out.println(pq.remove());
            System.out.println(pq.remove());    //Throws Out of bounds exeption
            ints.get(100);                      //Throws out of bounds exeption

            //Deque
            //  Double ended Queue, can retrieve from either end.

            //Map

            //HashMap  
            //      HashMap is like Hash Table, but is not syncronized and is faster
            Map<String, String> hashedStrings = new HashMap();
            hashedStrings.put("Key", "Value");
            hashedStrings.put("Another Key", "Another Value");
            System.out.println(hashedStrings);

            //TreeMap
            //      Like TreeSet, is going to organize the elements according to thier natural sorting order
            Map<String, String> dic = new TreeMap();
            dic.put("aardvark","a difficult to spell animal");
            dic.put("hammer","a thing to hit things with");
            dic.put("car", "a thing to go places");
            System.out.println(dic);
            System.out.println(dic.keySet());
            System.out.println(dic.values());
            System.out.println(dic.values().getClass());
            }

            //ITERATOR
            [COLLECTION_TYPE, i,e: List]Interator<c> cIterator = (field of type c).listIterator();
            while(cIterator.hasNext()){
                System.out.println(cIterator.next());
            }
                //EXAMPLE
                Iterator<String> dicIterator = dic.keySet().iterator();
                    while(dicIterator.hasNext()){
                        System.out.println(dicIterator.next());

            }

    }

Exeptions


    int[] arr = new int[3];
    System.out.println(arr[10])     //array Index Out of bounds
    //You know exceptions like the back of your hand.
    //  Oh hey that's new.


Threads

    A thread is a subprocess away from the normal execution flow.
    Each thread gets its own Stack, but all threads share the Heap.
    This is also known as multithreading.
        (thread concurrancy, asyncronus operations)

    Thread priority (set with int between 1 and 10 with 10 being the highest priority) symbolizes the importance of the thread's process.
        default priority is 5.
        The schedular determines what thread to run next based on its priority.
    
    the states of a thread(thread lifecycle)
        New - newly created thread that has not begun execution
        
        Runnable - the thread is ready to be ran, determined by the schedular.

        Blocked -   Its waiting to aquire a syncronous resource to become available to perform its opperation.

        Waiting -   Waiting for another Thread to finish its operation for an undetermined time.

        TimedWaiting - Waiting for another thread to complete execution for a givein ammount of time.

        Terminated - the thread has completed its execution

    Creating a thread:
        
        Extend the Thread class into a Custom class
            override the run method
        Use an instance of an implimented Runnable interface in the constructor of the Thread.

    multithreading issues:

        Starvation  - A situation where a thread with a lower priority is not allowed to run due to the other threads' priorities.

        DeadLock    - A situation where 2 threads hav eholds on resources. one thread needs the other's resources to complete its opperation,
                      and the same hoes for the other thread to let go of its resources. Since niehter thread can gain access to the resource its needs,
                      it is in DeadLock.

        Producer-Consumer Problem   -   One thread produces data, the other consumes the information. When they are out of sync and working faster than the other, this creates
                                        data overflow or data starvation. 

    User threads vs daemon threads  

        user threads - threads that run concurrantly with the main thread with the purpose of joining the main thread

        daemon threads - therads that run in the background who's purpose is outside of the main thread's concern. (garbage collector)
                            Not ment to rejoin the main thread
    
    Methods of threads
        getters and setters for id, name, priority
        interrupt() - intteruptst the thread
        isAlive(), isInterupted, isDaemon - tests the state of the thread
        join() - wait for the thread to finish execution
        start() - starts the thread an begins execution

        static methods
            currentThread - returns the current thread that is executing
            sleep(long milliseconds) - causes the currently executing thread to sleep for X ms.

Garbage Collections 

        The GC will clean unrefferenced objects out of the Heap

        when an Object has no more elements refernecing it, then it is eligible for garbage collection

        System.gc()         //requests for the gc, but does not determin when it will run

        the GC will call an Object's finalize method before the Object is destroyed

        the purpose of the finalize method is to give last minute instructions to the object

        if you need something done at the end of the program, do not rely on the finalize method, it is better to
            put it in a finally block

        Object o1 = new Object(); (A)
        Object o2 = o1;
        o1 = null;          // Object  (A) not eligable for Garbage Collection, o2 still references it.
        o2 = null;          // Object  (A) now eligable for Garbage Collection

        
ByteStream
    //Write
    try{
        FileOutputStream fos = new FileOutputStream(filename); //write to string filename
        fos.write(73);
        fos.write(25);
        fos.write(12);

        fos.close();

    }catch (FileNotFoundException e){
        e.printStackTrace();
    }catch (IOException e){
        e.printStackTrace();
    }
    //Read
    try(InputStream is = new FileInputStream(filename)){ //try with resources block. This will automatically close any resource within it.
        int i;
        while((i=is.read()) != -1){
            System.out.println(i);
        }
    }catch(FileNotFoundException e){
        e.printStackTrace();
    }catch(IOException e){
        e.printStackTrace();
    }

CharacterStream
    //Write
    try(FileWriter fos = new FileWriter(filename)){ //write to string filename
        for(int i = 62; i<74; i++)
            fos.write(i);

    }catch (IOException e){
        e.printStackTrace();
    }
    //Read
    try(FileReader is = new FileReader(filename)){ //try with resources block. This will automatically close any resource within it.
        int i;
        while((i=is.read()) != -1){
            System.out.println((char)i);
        }

    }catch(IOException e){
        e.printStackTrace();
    }

BufferedCharacterStream
    //Write
    try(BufferedWriter bf = new BufferedWriter(new FileWriter(filename))){  //write to string filename
        bf.write("Hello File\n);        //\n is required to seperate strings
        bf.write("tucker\n");
        bf.write("dawit\n");
        bf.write("kyle");


    }catch(IOException e){
        e.printStackTrace
    }
    //Read
    try(BufferedReader br = new BufferedReader(new FileREader(filename)))
        String line ="";
        while (line = br.readLine()!=null){
            System.out.println(line);
        }
    }catch(IOException e){
        e.printStackTrace();
    }
Serialization
    
    Public Person implements Serializeable{
        int age = 0;
        transient private ssn = 000000001; //doesn't copy into output streams
    }

    Person o = new Person();
    //Write
    try(ObjectOutputStream oos = new ObjectOutputStream(New FileOutputStream(filename))){ //write to string filename
        oos.writeObject((Object)o);
     }catch(IOException e){
        e.printStackTrace
    }
    //Read
    try(ObjectInputStream ios = new ObjectInputStream(New FileInputStream(filename))){
        System.out.println((Person)ios.readObject());

    }catch(ClassNotFoundException e){
        e.printStackTrace();
    }catch(IOException e){
        e.printStackTrace();
    }

Scanner

    // Scanner is ment to gather input from the console and files.
    // Scanener cannot be opened once closed, no matter the circumstances inside the same program


    Scanner scanner = new Scanner(System.in);

    System.out.println("What is your name?);
    String name = scanner.nextline();
    System.out.println("The name you entered is " + name);
    
